{"ast":null,"code":"import _regeneratorRuntime from\"/Users/drallek/Desktop/Cryptosphere/hashlips_nft_minting_dapp/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";import _asyncToGenerator from\"/Users/drallek/Desktop/Cryptosphere/hashlips_nft_minting_dapp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";// log\nimport store from\"../store\";var fetchDataRequest=function fetchDataRequest(){return{type:\"CHECK_DATA_REQUEST\"};};var fetchDataSuccess=function fetchDataSuccess(payload){return{type:\"CHECK_DATA_SUCCESS\",payload:payload};};var fetchDataFailed=function fetchDataFailed(payload){return{type:\"CHECK_DATA_FAILED\",payload:payload};};export var fetchData=function fetchData(){return/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(dispatch){var totalSupply;return _regeneratorRuntime().wrap(function _callee$(_context){while(1)switch(_context.prev=_context.next){case 0:dispatch(fetchDataRequest());_context.prev=1;_context.next=4;return store.getState().blockchain.smartContract.methods.totalSupply().call();case 4:totalSupply=_context.sent;// let cost = await store\n//   .getState()\n//   .blockchain.smartContract.methods.cost()\n//   .call();\ndispatch(fetchDataSuccess({totalSupply:totalSupply// cost,\n}));_context.next=12;break;case 8:_context.prev=8;_context.t0=_context[\"catch\"](1);console.log(_context.t0);dispatch(fetchDataFailed(\"Could not load data from contract.\"));case 12:case\"end\":return _context.stop();}},_callee,null,[[1,8]]);}));return function(_x){return _ref.apply(this,arguments);};}();};","map":{"version":3,"names":["store","fetchDataRequest","type","fetchDataSuccess","payload","fetchDataFailed","fetchData","dispatch","getState","blockchain","smartContract","methods","totalSupply","call","console","log"],"sources":["/Users/drallek/Desktop/Cryptosphere/hashlips_nft_minting_dapp/src/redux/data/dataActions.js"],"sourcesContent":["// log\nimport store from \"../store\";\n\nconst fetchDataRequest = () => {\n  return {\n    type: \"CHECK_DATA_REQUEST\",\n  };\n};\n\nconst fetchDataSuccess = (payload) => {\n  return {\n    type: \"CHECK_DATA_SUCCESS\",\n    payload: payload,\n  };\n};\n\nconst fetchDataFailed = (payload) => {\n  return {\n    type: \"CHECK_DATA_FAILED\",\n    payload: payload,\n  };\n};\n\nexport const fetchData = () => {\n  return async (dispatch) => {\n    dispatch(fetchDataRequest());\n    try {\n      let totalSupply = await store\n        .getState()\n        .blockchain.smartContract.methods.totalSupply()\n        .call();\n      // let cost = await store\n      //   .getState()\n      //   .blockchain.smartContract.methods.cost()\n      //   .call();\n\n      dispatch(\n        fetchDataSuccess({\n          totalSupply,\n          // cost,\n        })\n      );\n    } catch (err) {\n      console.log(err);\n      dispatch(fetchDataFailed(\"Could not load data from contract.\"));\n    }\n  };\n};\n"],"mappings":"sTAAA;AACA,MAAOA,MAAK,KAAM,UAAU,CAE5B,GAAMC,iBAAgB,CAAG,QAAnBA,iBAAgB,EAAS,CAC7B,MAAO,CACLC,IAAI,CAAE,oBACR,CAAC,CACH,CAAC,CAED,GAAMC,iBAAgB,CAAG,QAAnBA,iBAAgB,CAAIC,OAAO,CAAK,CACpC,MAAO,CACLF,IAAI,CAAE,oBAAoB,CAC1BE,OAAO,CAAEA,OACX,CAAC,CACH,CAAC,CAED,GAAMC,gBAAe,CAAG,QAAlBA,gBAAe,CAAID,OAAO,CAAK,CACnC,MAAO,CACLF,IAAI,CAAE,mBAAmB,CACzBE,OAAO,CAAEA,OACX,CAAC,CACH,CAAC,CAED,MAAO,IAAME,UAAS,CAAG,QAAZA,UAAS,EAAS,CAC7B,iGAAO,iBAAOC,QAAQ,mIACpBA,QAAQ,CAACN,gBAAgB,EAAE,CAAC,CAAC,sCAEHD,MAAK,CAC1BQ,QAAQ,EAAE,CACVC,UAAU,CAACC,aAAa,CAACC,OAAO,CAACC,WAAW,EAAE,CAC9CC,IAAI,EAAE,QAHLD,WAAW,eAIf;AACA;AACA;AACA;AAEAL,QAAQ,CACNJ,gBAAgB,CAAC,CACfS,WAAW,CAAXA,WACA;AACF,CAAC,CAAC,CACH,CAAC,+EAEFE,OAAO,CAACC,GAAG,aAAK,CAChBR,QAAQ,CAACF,eAAe,CAAC,oCAAoC,CAAC,CAAC,CAAC,mEAEnE,+DACH,CAAC"},"metadata":{},"sourceType":"module"}